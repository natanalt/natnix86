; # High-Level Constructs macro package for NASM
; A set of macros providing high level constructs like conditionals and loops,
; for NASM.
; 
; by Natalia Cholewa <3
;
; ## Usage requirements
; Code generated by those macros is very simple (just `cmp`s, `jmp`s and 
; conditional branches), so it can work in every x86 mode of operation. Aside
; from modifying flags through `cmp`, no registers are modified, the stack is
; entirely unused, etc.
;
; One important thing to remember, is that those constructs depend on the NASM
; preprocessor's context stack. Whenever you call something like elif, else
; or end, remember to keep the context stack in the same way as it was left for
; you by the macros, otherwise things will break.
;
; ## Macros
;  * if lhs, operator, rhs
;  * if_flag flag name, set/clear           NOT IMPLEMENTED
;  * elif lhs, operator, rhs
;  * elif_flag flag name, set/clear         NOT IMPLEMENTED
;  * else
;  * while lhs, operator, rhs
;  * until lhs, operator, rhs
;  * oncontinue
;  * end
;
; ## Example usage
;   if ax, =, 20
;       ; Do something
;   elif bx, <, 500
;       ; Do something else
;   elif_flag carry, clear
;       ; Behavior!
;   else
;       ; Do something completely different!
;   end
;
;   ; Call breakpoint 50 times
;   mov eax, 50
;   while eax, !=, 0
;       int 0x03
;
;       ; Here oncontinue is kinda unnecessary, but with larget structures, with
;       ; branches calling continue and so on, it can be useful 
;   oncontinue
;       dec eax
;   end
;
;   ; Do the same thing, but differently
;   mov eax, 50
;   until eax, =, 0
;       int 0x03
;       dec eax
;   end
;
; ## Supported comparison operators
;  * =
;  * !=
;  * > (note: signed)
;  * < (note: signed)
;  * <= (note: signed)
;  * >=
;
; ## Supported flags (for if_flag, elif_flag)
;  * carry | c
;  * zero | z
;

%ifndef HLC_INCLUDED
%define HLC_INCLUDED

%define HLC_LIB_VERSION "0.1.0"

; To make sure there's *something* on the stack
; very hacky, i know
%push

;; Conditionals
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;
;; Implementation of branch jumps based on provided operator string
;; Used by if and elif, so it's moved into a separate macro
;;
;; Params:
;;  %1 - operator string
;;  %2 - label to jump to in the case opposite to the operator
;;       (for example, = operator will output jne, != will output je) 
%macro hlc_cmp_op_impl 2
    %if %1 == "="
        jne %2
    %elif %1 == "!="
        je %2
    %elif %1 == ">"
        jle %2
    %elif %1 == "<"
        jge %2
    %elif %1 == ">="
        jl %2
    %elif %1 == "<="
        jg %2
    %else
        %error Unknown comparison operator '%$operator'
    %endif
%endmacro


%macro if 3
    %push hlc_if
    %defstr %$operator %2
    hlc_push_ensure_loop_stuff

    %assign %$if_depth 1
    
    cmp %1, %3
    hlc_cmp_op_impl %$operator, %$if_fall_down
%endmacro


%macro elif 3
    %ifnctx hlc_if
        %ifnctx hlc_elif
            %error Expected 'if' or 'elif' before 'elif'
        %endif
    %endif
    
    jmp %$if_finish
    %$if_fall_down:

    %push hlc_elif
    %assign %$if_depth %$$if_depth + 1
    hlc_push_ensure_loop_stuff

    cmp %1, %3
    %defstr %$operator %2
    hlc_cmp_op_impl %$operator, %$if_fall_down
%endmacro


%macro else 0
    %ifnctx hlc_if
        %ifnctx hlc_elif
            %error Expected 'if' or 'elif' before 'else'
        %endif
    %endif
    
    jmp %$if_finish
    %$if_fall_down:
    %push hlc_else
    hlc_push_ensure_loop_stuff
    
%endmacro

;; Loops
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; An infinite loop, supports 'break' and 'continue'
%macro repeat 0
    %push hlc_loop
    %define %$hlc_loop_exists
    %$loop_start:
%endmacro


;; Unconditionally exits the current loop
%macro break 0
    %ifndef %$hlc_loop_exists
        %error Expected an open loop before 'break'
    %endif
    jmp %$loop_finish
%endmacro


;; Finishes the current loop iteration and jumps back to its beginning
%macro continue 0
    %ifndef %$hlc_loop_exists
        %error Expected an open loop before 'continue'
    %endif
    jmp %$loop_continue
%endmacro


%macro until 3
    repeat
        if %1,%2,%3
            break
        end
%endmacro


%macro while 3
    repeat
        ; a bit hacky but whatever
        if %1,%2,%3
        else
            break
        end
%endmacro


%macro oncontinue 0
    %ifndef %$hlc_loop_exists
        %error Expected an open loop before 'oncontinue'
    %endif

    %define %$hlc_oncontinue_exists
    %$loop_continue:
%endmacro

;; Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%macro fn 1
    %push hlc_fn

    %defstr %$fn_name_str %1
    %deftok %$fn_name %$fn_name_str

    align 2
    global %$fn_name
    %$fn_name:
%endmacro

;; Miscellaneous
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%macro end 0
    %ifctx hlc_if
        %$if_fall_down:
        %pop
    %elifctx hlc_else
        %pop
        %rep %$if_depth
            %$if_finish:
            %pop
        %endrep
    %elifctx hlc_elif
        %$if_fall_down:
        %pop
        %rep %$if_depth
            %$if_finish:
            %pop
        %endrep
    %elifctx hlc_loop
        %ifndef %$hlc_oncontinue_exists
            %$loop_continue equ %$loop_start
        %endif
        jmp %$loop_start
        %$loop_finish:
        %pop
    %elifctx hlc_fn
        .hlc_fn_end:
        %$fn_name %+ .size equ %$fn_name %+ .hlc_fn_end - %$fn_name
        %pop
    %else
        %error end: Unexpected 'end'
    %endif
%endmacro


%macro hlc_push_ensure_loop_stuff 0
    %ifdef %$$hlc_loop_exists
        %define %$hlc_loop_exists
        %$loop_finish equ %$$loop_finish
        %$loop_start equ %$$loop_start
    %endif
%endmacro

%endif ; HLC_INCLUDED
